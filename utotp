#!/usr/bin/python3
# encoding=UTF-8

# Copyright Â© 2018 Jakub Wilk <jwilk@jwilk.net>
# SPDX-License-Identifier: MIT

import argparse
import base64
import binascii
import hashlib
import hmac
import struct
import sys
import time

lambda: (yield from 0)  # Python >= 3.3 is required

default_len = 6

def hotp(*, key, n, len=default_len, dgst=hashlib.sha1):
    # RFC 4226
    msg = struct.pack('>Q', n)
    mac = hmac.HMAC(key=key, msg=msg, digestmod=dgst)
    mac = mac.digest()
    offset = mac[-1] & 0xF
    code = mac[offset:(offset + 4)]
    [code] = struct.unpack('>I', code)
    code = code & ~(1 << 31)
    code = str(code)[-len:]
    return code

def totp(*, key, len=default_len, dgst=hashlib.sha1, step=30):
    # RFC 6238
    t = int(time.time()) // step
    return hotp(key=key, n=t, len=len, dgst=dgst)

def b32decode(s):
    s = s.strip()
    s = s.upper()
    modlen = len(s) % 8
    if modlen > 0:
        s += '=' * (8 - modlen)
    assert len(s) % 8 == 0
    return base64.b32decode(s)

def main():
    ap = argparse.ArgumentParser()
    ap.set_defaults(len=default_len)
    for i in (6, 7, 8):
        msg = 'print {0} digits'.format(i)
        if i == default_len:
            msg += ' (default)'
        ap.add_argument('-{0}'.format(i), dest='len', action='store_const', const=i, help=msg)
    opts = ap.parse_args();
    key = sys.stdin.read()
    try:
        key = b32decode(key)
    except binascii.Error:
        print('{prog}: secret key cannot be base32-decoded'.format(prog=ap.prog), file=sys.stderr)
        sys.exit(1)
    code = totp(key=key, len=opts.len)
    print(code)

if __name__ == '__main__':
    main()

# vim:ts=4 sts=4 sw=4 et
